{
  "version": 3,
  "sources": ["../../src/scripts/sfmx/lexer.ts", "../../src/scripts/sfmx/parse.ts", "../../src/scripts/main.ts"],
  "sourcesContent": ["enum TokenType {\n    Identifier = 'A-z',\n    Number = '0-9',\n    CloseParen = ')',\n    OpenParen = '(',\n    CloseBrace = '}',\n    OpenBrace = '{',\n    Point = '.',\n    Comma = ',',\n    Semicolon = ';',\n    Equals = '=',\n    Slash = '/',\n    Asterisk = '*',\n    Minus = '-',\n    NewLine = '\\n',\n    Invalid = 'Invalid'\n}\n\nclass Token {\n    public readonly type: TokenType;\n    public readonly value?: string;\n    public readonly cursor: number;\n\n    constructor(type: TokenType, cursor: number, value?: string) {\n        this.type = type;\n        this.cursor = cursor;\n        this.value = value;\n    }\n};\n\n// - - -\n\nconst chars = [\n    '(', ')', '{', '}', '.', ';', '=', '/', '*', '-', ','\n]\n\nconst lexer = (data: string) => {\n    const tokens: Token[] = [];\n\n    const content = data.split('')\n        .filter((char) => ['\\r', '\\t', ' '].includes(char) === false)\n        .join('');\n    \n    const size = data.length;\n\n    for (let i = 0; i < size; i++) {\n        const char = content[i] as TokenType;\n\n        if (char === undefined) break\n\n        if (char.match(/[A-Za-z]|\\./)) {\n            let value: string = char;\n\n            while (content[i + 1].match(/[A-Za-z]|\\.|_/)) {\n                value += content[++i];\n            }\n\n            i--;\n\n            tokens.push(\n                new Token(TokenType.Identifier, i, value)\n            );\n        }\n\n        else if (char.match(/[0-9]/)) {\n            let value: string = char;\n            let isFloat = false;\n\n            while (content[i + 1].match(/[0-9]|\\./)) {\n                const char = content[++i];\n\n                if (char === '.') {\n                    if (isFloat) {\n                        tokens.push(\n                            new Token(TokenType.Invalid, i, value)\n                        );\n\n                        break;\n                    }\n\n                    isFloat = true;\n                }\n\n                value += char;\n            }\n\n            i--;\n\n            tokens.push(\n                new Token(TokenType.Number, i, value)\n            );\n        }\n\n        else if (char === '/') {\n            if (content[i + 1] === '/') {\n                while (content[++i] !== '\\n') {\n                    continue;\n                }\n\n            }\n\n            if (content[i + 1] === '*') {\n                while (content[++i] !== '*' && content[i + 1] !== '/') {\n                    continue;\n                }\n\n            }\n\n            continue;\n        }\n\n        else if (chars.includes(char)) {\n            tokens.push(new Token(char, i));\n\n            continue;\n        }\n\n        else if (char === '\\n') {\n            continue;\n        }\n\n        else {\n            tokens.push(\n                new Token(TokenType.Invalid, i, char)\n            );\n        }\n\n        i++;\n    }\n\n    return tokens;\n}\n\nexport { lexer, Token, TokenType };\n", "import { Token, TokenType } from './lexer';\n\nenum NodeType {\n    Attribute,\n    Object,\n}\n\nclass AttributeNode {\n    public name: string\n    public value: string\n\n    constructor(name: string, value: string) {\n        this.value = value;\n        this.name = name;\n    }\n}\n\nclass Node {\n    public name: string\n    public args: string[]\n    public values: (AttributeNode | Node)[]\n\n    constructor(name: string, args: string[], values: (AttributeNode | Node)[]) {\n        this.name = name;\n        this.args = args;\n        this.values = values;\n    }\n}\n\n// - - -\n\ninterface Parser {\n    cursor: number\n}\n\nfunction parseObjectValues(this: Parser, identifiers: Token[]): (AttributeNode | Node)[] {\n    const length: number = identifiers.length;\n    const data = [];\n\n    while (this.cursor < length) {\n        if (identifiers[this.cursor].type === TokenType.CloseBrace)\n            break;\n\n        if (identifiers[this.cursor].type === TokenType.Identifier) {\n            const name = identifiers[this.cursor].value!;\n\n            if (identifiers[++this.cursor].type === TokenType.Equals) {\n                if (\n                    [TokenType.Identifier, TokenType.Number, TokenType.Minus]\n                        .includes(identifiers[++this.cursor].type) === false\n                ) {\n                    throw new Error('Unexpected token');\n                }\n\n                if (identifiers[this.cursor].type === TokenType.Minus) {\n                    if (identifiers[++this.cursor].type !== TokenType.Number) {\n                        throw new Error('Unexpected token');\n                    }\n\n                    data.push(\n                        new AttributeNode(name, '-' + identifiers[this.cursor].value!)\n                    );\n                }\n\n                data.push(\n                    new AttributeNode(name, identifiers[this.cursor].value!)\n                )\n            }\n\n            if (identifiers[this.cursor--].type === TokenType.OpenParen) {\n                data.push(\n                    new Node(name, [], parseObjectValues.call(this, identifiers))\n                );\n            }\n        }\n\n        this.cursor++;\n    }\n\n    return data;\n}\n\nfunction parseObjectDef(this: Parser, identifiers: Token[], root?: true): Node[] {\n    const length: number = identifiers.length;\n    const data: Node[] = [];\n\n    while (this.cursor < length) {\n        if (\n            identifiers[this.cursor].type === TokenType.CloseBrace &&\n            root === undefined\n        )\n            break;\n            \n        if (\n            [\n                TokenType.Identifier, TokenType.OpenParen\n            ].every(\n                (type, i) => identifiers[this.cursor + i].type === type\n            )\n        ) {\n            // Object name\n            const name = identifiers[this.cursor].value!;\n\n            this.cursor += 2;\n\n            // Object arguments\n            const args: string[] = [];\n\n            while (identifiers[this.cursor].type !== TokenType.CloseParen) {\n                if (identifiers[this.cursor].type === TokenType.Identifier) {\n                    args.push(identifiers[this.cursor++].value!);\n                } else {\n                    throw new Error('Unexpected token');\n                }\n            }\n\n            console.log(identifiers[this.cursor], identifiers[this.cursor + 1])\n\n            if (identifiers[++this.cursor].type !== TokenType.OpenBrace) {\n                throw new Error('Unexpected token');\n            }\n\n            this.cursor++;\n\n            // Object values\n            const values: (AttributeNode | Node)[] = parseObjectValues.call(\n                this, identifiers\n            );\n\n            data.push(\n                new Node(name, args, values)\n            );\n        } else {\n            throw new Error('Unexpected token');\n        }\n\n        this.cursor++;\n    }\n\n    return data;\n}\n\nconst parser = (data: Token[]) => {\n    return parseObjectDef.call({ cursor: 0 }, data);\n}\n\nexport { parser, Node, NodeType, AttributeNode };\n", "import { Token, lexer } from './sfmx/lexer';\nimport { parser, Node } from './sfmx/parse';\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement;\nconst ctx = canvas.getContext('2d')!;\n\nconst height = canvas.height = window.innerHeight / 4;\nconst width = canvas.width = window.innerWidth / 4;\n\ninterface SFDX {\n    name: string\n    attributes: {\n        [key: string]: string\n    }[]\n}\n\nconst updateTreeViewer = (data: SFDX[]) => {\n\n}\n\nconst stringToSFDX = (content: string): Node[] => {\n    \n    const identifiers = lexer(content);\n\n    console.log(identifiers);\n\n    const data = parser(identifiers);\n\n    return data;\n}\n\ndocument.querySelector('form')\n    ?.addEventListener('submit', async (e) => {\n        e.preventDefault();\n\n        const data = Object.fromEntries(\n            new FormData(e.target as HTMLFormElement)\n        );\n\n        const file = await (data['file'] as File).arrayBuffer()\n\n        const sfdx = stringToSFDX(\n            new TextDecoder('utf-8').decode(file)\n        );\n\n        console.log(sfdx);\n    })\n"],
  "mappings": "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",
  "names": ["Token", "type", "cursor", "value", "chars", "lexer", "data", "tokens", "content", "char", "size", "i", "isFloat", "AttributeNode", "name", "value", "Node", "args", "values", "parseObjectValues", "identifiers", "length", "data", "parseObjectDef", "root", "type", "i", "parser", "canvas", "ctx", "height", "width", "stringToSFDX", "content", "identifiers", "lexer", "parser", "file", "sfdx"]
}
